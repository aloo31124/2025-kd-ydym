/*
 * File: app/view/TouchTreeGrid.js
 *
 * This file was generated by Sencha Architect version 3.2.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.4.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.4.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('OA.components.TouchTreeGrid', {
    extend: 'Ext.Container',
    alias: 'widget.touchtreegrid',

    config: {
        store: '',
        listScrollable: true,
        contentItemTpl: '',
        disableSelection: true,
        onItemDisclosure: false,
        headerTpl: '',
        variableHeights: true,
        itemHeight: 35,
        disclosureProperty: 'disclose',
        listItemId: 'touchtreegridlist',
        categItemTpl: '',
        includeFooter: true,
        categIndentPct: '3',
        colNumberToTruncateForIndents: 1,
        includeFooterLevels: true,
        categDepthColors: false,
        customExpCollapseEvent: '',
        categDepthColorButtons: true,
        categItemTplOverride: '',
        contentItemTplOverride: '',
        headerTplOverride: '',
        includeHeader: true,
        applyDefaultCollapseLevel: true,
        defaultCollapseLevel: 99,
        landscapeIcon: '',
        helpHtml: '',
        pressedCls: 'touchtreegrid-item-pressed',
        simpleList: false,
        columnSorting: false,
        styleContentRow: '',
        styleCategRow: '',
        styleHeaderRow: '',
        singleExpand: false,
        selectedCls: 'touchtreegrid-item-selected',
        mode: 'SINGLE',
        useSimpleItems: true,
        infinite: true,
        arrowPctWidth: '8',
        customColumnSortEvent: '',
        disableExpandCollapse: false,
        cssContentRow: 'css-content-row ',
        cssCategRow: 'css-categ-row ',
        cssHeaderRow: 'css-header-row ',
        includeCustomFooterItems: false,
        footerDock: 'bottom',
        hideExpandCollapseBtns: false,
        linkedGridsParentItemId: '',
        styleSimpleRow: '',
        cssSimpleRow: '',
        includeThumb: false,
        cls: 'x-touchtreegrid-list',
        itemId: 'touchtreegrid',
        layout: 'vbox',
        list: {
            
        },
        columns: [
            
        ],
        header: {
            xtype: 'toolbar',
            docked: 'top',
            cls: 'touchtreegrid-header'
        },
        footer: {
            xtype: 'toolbar',
            docked: 'bottom',
            ui: 'light',
            cls: 'touchtreegrid-footer'
        },
        listPlugins: {
            
        },
        categDepthColorsArr: [
            '#a6a6a6',
            '#dddddd',
            'white'
        ],
        renderers: {
            
        },
        additionalListConfigs: {
            
        },
        categColumns: [
            
        ],
        categCssArr: [
            
        ],
        customFooterItems: {
            
        },
        onScrollOptions: {
            
        },
        linkedGridsArr: [
            
        ],
        thumbConfig: {
            className: 'Ext.Container',
            height: '40px',
            width: '30px',
            offset: '1px',
            top: '5px',
            style: 'background-color: #605d52; opacity:0.85; border-radius: .5em; border: 1px solid gray;',
            zIndex: 9,
            includeLine: true,
            lineColor: 'red',
            enableDrag: false,
            enableDragEnd: true
        }
    },

    initialize: function(config) {
        var me = this;

        me.callParent(arguments);

        this.doRefreshList();

        // Process linked grids for synchronized scrolling if applicables
        if (me.getLinkedGridsArr().length>0) {
            var listItemId = me.getListItemId();
            var gridlist = me.down('#'+listItemId);
            var scroller = gridlist.getScrollable().getScroller();
            scroller.on('scroll',   me.onScroll, me, me.getOnScrollOptions());
        }
    },

    updateColumns: function() {
        // UPDATE functions on config items execute prior to INITIALIZE (and before UPDATESTORE) so
        // insert logic here to build ItemTpl components
        // NOTE:  Columns updated in this Class as [initialize] to force execution of this function.

        var me = this, myWidth, myWidthVal;

        var simpleList = me.getSimpleList();

        // Proceed to build TPL for header row
        var styleStr = '', rendStr='', cssStr='', idxStr = '';
        var categ = me.getCategItemTplOverride();
        var indent = me.getCategIndentPct().toString().replace("%", ""); // % of window to indent per level (starting at 0% ... default =3%)
        var arrowWid = me.getArrowPctWidth().toString().replace("%", ""); // allow control over percent screen width that category arrow consumes (def = 4%)


        var categStyle = Ext.isEmpty(me.getStyleCategRow()) ? '' : ' style="' + me.getStyleCategRow() + '"';
        var contentStyle = Ext.isEmpty(me.getStyleContentRow()) ? '' : ' style="' + me.getStyleContentRow() + '"';
        var simpleStyle = Ext.isEmpty(me.getStyleSimpleRow()) ? '' : ' style="' + me.getStyleSimpleRow() + '"';    // SWL added 11/22/14

        var categCss = Ext.isEmpty(me.getCssCategRow()) ? '' : ' class="' + me.getCssCategRow() + '"';
        var contentCss = Ext.isEmpty(me.getCssContentRow()) ? '' : ' class="' + me.getCssContentRow() + '"';
        var simpleCss = Ext.isEmpty(me.getCssSimpleRow()) ? '' : ' class="' + me.getCssSimpleRow() + '"';   // SWL added 11/22/14

        var indentCol = me.getColNumberToTruncateForIndents()-1; // This column width value will be truncated to account for indent
        // Subtract 1 from column number to array index # applied below.
        // Width expected to be in pct format as last '%' character will be stripped for computation : '25%'

        var data = me.getColumns(); // single dimention array of objects defining each column
        var categData = me.getCategColumns(); // optional multi-dimension array of objects of category columns defs by level

        if (this.isObjectEmpty(data)) {
            // Initialize column data for scenario where column array updated within controller after component initialization
            data ={header: '', dataIndex: '', width: '', style: '', categStyle: '', headerStyle: ''};
        }

        var shellArr=[], i, k, categArr=[],
            prefixArr = ['<div' + categStyle + categCss + '>'];

        if (parseInt(indent) > 0) {
            prefixArr.push('<div align="left" style="width:{[(values.depth-1)*'+indent+']}%;"></div>');  // 3% per depth starting at 0%
        }
        if (parseInt(arrowWid) > 0) {
            prefixArr = prefixArr.concat([
                '<div align="left" style="width:'+arrowWid+'%;min-width:'+arrowWid+'%;max-width:'+arrowWid+'%;white-space: nowrap;overflow:hidden;text-overflow:ellipsis;">',
                '<span class="touchtreegrid-details-img ',
                '<tpl if="this.isExpanded(values)">',
                'touchtreegrid-details-img-open' ,
                '<tpl else>',
                'touchtreegrid-details-img-close' ,
                '</tpl>',
                '"</span>',
                '</div>'
            ]);
        }

        if (categ==='' && !simpleList && Ext.isEmpty(categData)) {
            // Process category row TPL (same TPL for all category rows defined via Columns array)

            shellArr.push(prefixArr.join(''));
            for (i=0; i<data.length; i++) {

                // Use categStyle if exists, else apply detail row style to category row
                if (!Ext.isEmpty(data[i].categStyle) && data[i].categStyle > '') {styleStr = data[i].categStyle;}
                else if (!Ext.isEmpty(data[i].style)) {styleStr = data[i].style;}
                else {styleStr = '';}

                // Use categCss if exists, else apply detail row css to category row (if defined)
                if (!Ext.isEmpty(data[i].categCss) && data[i].categCss > '') {cssStr = data[i].categCss;}
                else if (!Ext.isEmpty(data[i].css)) {cssStr = data[i].css;}
                else {cssStr = '';}

                // Substitute user-defined renderer string from Columns array if defined
                rendStr = (Ext.isEmpty(data[i].renderer) ? (Ext.isEmpty(data[i].dataIndex) ? '' : data[i].dataIndex) : '[' + data[i].renderer + ']');

                // Add dataIndex attribute to this DIV if requested in Columns array (for purposes of trapping cell tap)
                idxStr = ((!data[i].addDataIndexToDiv) ? '' : ' dataIndex="' + data[i].dataIndex + '"');

                if (i===indentCol && data[indentCol].width.indexOf('%') !== -1) {  // SWL UPDATED 1/17/2015 TO CORRECT FOR COMMON ERROR TRYING TO INDENT BY PCT WHEN WIDTH DEFINED IN PIXELS
                    // Subtract percentage width based on level
                    shellArr.push('<div class="touchtreegrid-list-categ-cell ' + cssStr + '" style="' +
                                  'min-width:{[' + data[i].width.replace("%", "") + '-((values.depth-1)*'+indent+')]}% !important;' +
                                  'max-width:{[' + data[i].width.replace("%", "") + '-((values.depth-1)*'+indent+')]}% !important;' +
                                  'width:{[' + data[i].width.replace("%", "") + '-((values.depth-1)*'+indent+')]}% !important;' +
                                  styleStr + '"' + idxStr + ' >{' + rendStr + '}</div>');
                } else {
                    shellArr.push('<div class="touchtreegrid-list-categ-cell " style="' +
                                  'min-width:' + data[i].width + ' !important;' +
                                  'max-width:' + data[i].width + ' !important;' +
                                  'width:' + data[i].width + ' !important;' +
                                  styleStr + '"' + idxStr + ' >{' + rendStr + '}</div>');
                }
            }

            shellArr.push('</div>');
            categ=shellArr.join('');
            me.setCategItemTpl(categ);
        }
        else if (categ==='' && !simpleList && !Ext.isEmpty(categData)) {
            // Process category row TPL as defined in categColumns.

            shellArr = [];
            shellArr.push(prefixArr.join(''));  // Initialize with arrow and row style definitions

            for (i=0; i<categData.length; i++) {  // loop for each object defined in current sub-array

                // Use categStyle if exists, else apply detail row style to category row
                if (!Ext.isEmpty(categData[i].categStyle) && categData[i].categStyle > '') {styleStr = categData[i].categStyle;}
                else if (!Ext.isEmpty(categData[i].style)) {styleStr = categData[i].style;}
                else {styleStr = '';}

                // Use categCss if exists, else apply detail row css to category row (if defined)
                if (!Ext.isEmpty(categData[i].categCss) && categData[i].categCss > '') {cssStr = categData[i].categCss;}
                else if (!Ext.isEmpty(categData[i].css)) {cssStr = categData[i].css;}
                else {cssStr = '';}

                // Substitute user-defined renderer string from Columns array if defined
                rendStr = ((!categData[i].renderer) ? (Ext.isEmpty(categData[i].dataIndex) ? '' : categData[i].dataIndex) : '[' + categData[i].renderer + ']');

                // Add dataIndex attribute to this DIV if requested in Columns array (for purposes of trapping cell tap)
                idxStr = ((!categData[i].addDataIndexToDiv) ? '' : ' dataIndex="' + categData[i].dataIndex + '"');


                if (i===indentCol && categData[indentCol].width.indexOf('%') !== -1) {  // SWL UPDATED 1/17/2015 TO CORRECT FOR COMMON ERROR TRYING TO INDENT BY PCT WHEN WIDTH DEFINED IN PIXELS
                    // Subtract percentage width based on level
                    shellArr.push('<div class="touchtreegrid-list-categ-cell ' + cssStr + '" style="' +
                                  'min-width:{[' + categData[i].width.replace("%", "") + '-((values.depth-1)*'+indent+')]}% !important;' +
                                  'max-width:{[' + categData[i].width.replace("%", "") + '-((values.depth-1)*'+indent+')]}% !important;' +
                                  'width:{[' + categData[i].width.replace("%", "") + '-((values.depth-1)*'+indent+')]}% !important;' +
                                  styleStr + '"' + idxStr + ' >{' + rendStr + '}</div>');
                } else {
                    shellArr.push('<div class="touchtreegrid-list-categ-cell ' + cssStr + '" style="' +
                                  'min-width:' + categData[i].width + ' !important;' +
                                  'max-width:' + categData[i].width + ' !important;' +
                                  'width:' + categData[i].width + ' !important;' +
                                  styleStr + '"' + idxStr + ' >{' + rendStr + '}</div>');
                }
            }

            shellArr.push('</div>');
            categArr=shellArr.join('');

            me.setCategItemTpl(categArr);

        }
        else {me.setCategItemTpl(categ);}  // simply update with TPL provided in CategItemTplOverride config (ignored for simpleList=true)

        var detail = me.getContentItemTplOverride();
        var detailArr, j;
        if (detail==='' && !simpleList) {
            detailArr = ['<div' + contentStyle + contentCss + '>'];
            if (parseInt(indent) > 0) {
                detailArr.push('<div align="left" style="width:{[(values.depth-1)*'+indent+']}%;"></div>');    // 3% per depth starting at 0%
            }
            if (parseInt(arrowWid) > 0) {
                detailArr.push('<div align="left" style="width:'+arrowWid+'%;min-width:'+arrowWid+'%;max-width:'+arrowWid+'%;white-space: nowrap;overflow:hidden;text-overflow:ellipsis;">&nbsp;</div>');
            }

            for (j=0; j<data.length; j++) {

                // Substitute user-defined renderer string from Columns array if defined
                rendStr = ((!data[j].renderer) ? (Ext.isEmpty(data[j].dataIndex) ? '' : data[j].dataIndex) : '[' + data[j].renderer + ']');

                // Add dataIndex attribute to this DIV if requested in Columns array (for purposes of trapping cell tap)
                idxStr = ((!data[j].addDataIndexToDiv) ? '' : ' dataIndex="' + data[j].dataIndex + '"');

                cssStr = (Ext.isEmpty(data[j].css)) ? '' : data[j].css;

                if (j===indentCol && data[indentCol].width.indexOf('%') !== -1) {  // SWL UPDATED 1/17/2015 TO CORRECT FOR COMMON ERROR TRYING TO INDENT BY PCT WHEN WIDTH DEFINED IN PIXELS
                    // Subtract percentage width based on level
                    detailArr.push('<div class="touchtreegrid-list-content-cell ' + cssStr + '" style="' +
                                   'min-width:{[' + data[j].width.replace("%", "") + '-((values.depth-1)*'+indent+')]}% !important;' +
                                   'max-width:{[' + data[j].width.replace("%", "") + '-((values.depth-1)*'+indent+')]}% !important;' +
                                   'width:{[' + data[j].width.replace("%", "") + '-((values.depth-1)*'+indent+')]}% !important;' +
                                   (Ext.isEmpty(data[j].style) ? '' : data[j].style) + '" ' + idxStr +
                                   '>{' + rendStr + '}</div>');
                } else {
                    detailArr.push('<div class="touchtreegrid-list-content-cell ' + cssStr + '" style="' +
                                   'min-width:' + data[j].width + ' !important;' +
                                   'max-width:' + data[j].width + ' !important;' +
                                   'width:' + data[j].width + ' !important;' +
                                   (Ext.isEmpty(data[j].style) ? '' : data[j].style) + '" ' + idxStr +
                                   '>{' + rendStr + '}</div>');
                }

            }

            detailArr.push('</div>');
            detail=detailArr.join('');
        }
        if (detail==='' && simpleList) {
            detailArr = [
                // webkit-box handled by  "display : inline-block;" in TouchTreeGrid.css
                //   '<div style="display: -webkit-box;-webkit-box-orient: horizontal;">',
            ];
            if (!Ext.isEmpty(simpleStyle) || !Ext.isEmpty(simpleCss)) {  // SWL added 11/22/14
                detailArr.push(['<div' + simpleStyle + simpleCss + '>']);
            }

            for (j=0; j<data.length; j++) {

                // Substitute user-defined renderer string from Columns array if defined
                rendStr = ((!data[j].renderer) ? data[j].dataIndex : '[' + data[j].renderer + ']');

                // Add dataIndex attribute to this DIV if requested in Columns array (for purposes of trapping cell tap)
                idxStr = ((!data[j].addDataIndexToDiv) ? '' : ' dataIndex="' + data[j].dataIndex + '"');

                cssStr = (Ext.isEmpty(data[j].css)) ? '' : data[j].css;

                detailArr.push('<div class="touchtreegrid-simplelist-cell ' + cssStr + '" style="' +
                               'min-width:' + data[j].width + ' !important;' +
                               'max-width:' + data[j].width + ' !important;' +
                               'width:' + data[j].width + ' !important;' +
                               (Ext.isEmpty(data[j].style) ? '' : data[j].style) + '" ' + idxStr +
                               '>{' + rendStr + '}</div>');
            }
            if (!Ext.isEmpty(simpleStyle) || !Ext.isEmpty(simpleCss)) {  // SWL added 11/22/14
                detailArr.push(['</div>']);
            }

            //   detailArr.push('</div>');
            detail=detailArr.join('');
        }
        var content = me.setContentItemTpl(detail);

    },

    updateStore: function(newStore, oldStore) {
        var me = this;

        var list = me.getList();
        var disableSel = me.getDisableSelection();
        var pressedCls = (disableSel ? '' : me.getPressedCls());  // Don't apply pressing class if selection disabled
        var selectedCls = me.getSelectedCls();
        var mode = me.getMode();
        var disclose = me.getOnItemDisclosure();
        var discloseProp = me.getDisclosureProperty();
        var itemHeight = me.getItemHeight();
        var variableHeights = me.getVariableHeights();
        var infinite = me.getInfinite();
        var useSimpleItems = me.getUseSimpleItems();

        // Added 6/28/2013
        if (newStore === "") {
            // Assume we are implementing dynamic grid and create temporary store to allow creation of List component
            newStore = Ext.create('Ext.data.Store', {fields: {"name" : "dynamic"}});
        }

        if (this.isObjectEmpty(list)) {

            list = Ext.create('Ext.dataview.List', {
                disableSelection: disableSel,
                onItemDisclosure : disclose,
                disclosureProperty : discloseProp,  // 'disclose' for all rows (default), 'leaf' for leafs only
                itemHeight: itemHeight,
                variableHeights: variableHeights,
                store: newStore,
                masked: false,
                itemCls: 'x-touchtreegrid-item',
                pressedCls : pressedCls,
                selectedCls : selectedCls,
                useSimpleItems: useSimpleItems,
                infinite: infinite,
                mode: mode,
                height: '100%'
            });

            // Support application of width, minWidth, height, minHeight overrides from linked instance for Horizontal scrolling
            var height = me.getHeight(); // Horiz scrolling doesn't work with 100% for some reason so any pixel setting
            // larger than expected works.  Example: 1000 (not sure why)
            if (!Ext.isEmpty(height)) {list.setHeight(height);}
            var minHeight = me.getMinHeight();
            if (!Ext.isEmpty(minHeight)) {list.setMinHeight(minHeight);}
            var width = me.getWidth();
            if (!Ext.isEmpty(width)) {list.setWidth(width);}
            var minWidth = me.getMinWidth();
            if (!Ext.isEmpty(minWidth)) {list.setMinWidth(minWidth);}

            list.on('itemtap', me.onItemTap, me);
            // SWL UPDATED 1/17/2015 TO SUPPORT RESIZING OF LOCKED COLUMNS
            if (me.getIncludeThumb()){
                list.on('refresh', me.prepLinkedGridsArr, me);
            }

            var plugins = me.getListPlugins();
            if (!this.isObjectEmpty(plugins)) {
                list.setPlugins(plugins);
            }

            me.setList(list);

            if (!me.getListScrollable()) {
                list.setScrollable({disabled: true});  // false doesn't seem to work
            } else {
                list.setScrollable(me.getListScrollable());
            }

            var listItemId = me.getListItemId();
            if (listItemId !== '') {
                list.setItemId(listItemId);
            }

            // Update list with any additional configs defined in user-defined additionalListConfigs object
            // (this allows all configs supported by Ext.dataview.List component to be applied to TouchTreeGrid list
            // Note:  any duplicated configs already supported by TouchTreeGrid will overwrite those and could have
            //        unexpected behaviour !!
            var addlConfigs = me.getAdditionalListConfigs();
            if (!me.isObjectEmpty(addlConfigs)) {
                for (cfg in addlConfigs) {
                    list.config[cfg] = addlConfigs[cfg];
                    list['_'+cfg] = addlConfigs[cfg];
                }
            }
            me.add(list);
        }
        else {
            list.setStore(newStore);
        }





    },

    onItemTap: function(list, index, target, record, e) {
        /**
        * Called when an list item has been tapped
        * @param list: {Ext.List}  The subList the item is on
        * @param index: {Number} The id of the item tapped
        * @param target: {Ext.Element} The list item tapped
        * @param record: {Ext.data.Record} The record whichw as tapped
        * @param e: {Ext.event.Event} The event
        */

        var store = list.getStore(),
            node = store.getAt(index),
            disabledExpColl = this.getDisableExpandCollapse();

        if (this.getOnItemDisclosure() && !Ext.isEmpty(e.getTarget('div.x-list-disclosure'))) {
            return;  // Ref:  http://www.sencha.com/forum/showthread.php?261518-List-onItemDisclosure-ST-2.2
        }

        if (this.getSimpleList() || node.isLeaf()) {
            this.fireEvent('leafItemTap', this, list, index, target, record, e);

        }
        else if (this.getSingleExpand() && !node.isExpanded()) {
            // If node collapsed, then expand this one and collapse all sibling nodes
            this.fireEvent('nodeItemTap', this, list, index, target, record, e);

            if (!disabledExpColl) {
                node.expand(false);
                var parent = node.parentNode;
                var children = parent.childNodes;
                for (var i=0; i<children.length; i++) {
                    if (children[i] !== node && children[i].isExpanded()) {
                        children[i].collapse();
                    }
                }
            }
        }
        else {
            this.fireEvent('nodeItemTap', this, list, index, target, record, e);

            if (!disabledExpColl && node.isExpandable()) {
                var xPosition = list.getScrollable().getScroller().position.x;
                var yPosition = list.getScrollable().getScroller().position.y;

                if (node.isExpanded()) {
                    node.collapse();
                } else {
                    node.expand(false);
                }

                list.getScrollable().getScroller().scrollTo(xPosition, yPosition, {duration: 0});
            }

        }
    },

    applyHeader: function(config) {
        if (this.getIncludeHeader()) {
            Ext.apply(config, {
                docked : 'top',
                cls    : 'touchtreegrid-header',
                itemId : 'touchtreegridheader'
            });

            return Ext.factory(config, Ext.Toolbar);
        }
    },

    updateHeader: function(header) {
        var me = this;
        if (me.getIncludeHeader()) {
            me.insert(0, header);

            if (this.getColumnSorting()) {  // add tap event listener to header toolbar
                header.element.on('tap', me["handleColumnSort"], me, {});
            }
        }
    },

    applyFooter: function(config) {
        var me = this;
        var footerDock = me.getFooterDock();
        var hideExpandCollapseBtns = me.getHideExpandCollapseBtns();
        var img = me.getLandscapeIcon();
        if (this.getIncludeFooter() && !this.getSimpleList()) {
            Ext.apply(config, {
                docked : footerDock,
                cls    : 'touchtreegrid-footer',
                itemId : 'touchtreegridbuttons',

                items: [
                {
                    xtype: 'label',
                    docked: 'right',
                    html: '',
                    itemId: 'touchtreegridlabel',
                    cls  : 'touchtreegrid-landscape-label',
                    style: 'color : white'
                },
                {
                    xtype: 'image',
                    docked: 'right',
                    hidden: true,
                    itemId: 'touchtreegridicon',
                    cls: 'touchtreegrid-landscape-icon',
                    src: img
                },
                {
                    xtype: 'segmentedbutton',
                    itemId : 'touchtreegridsegmentedbuttons',
                    hidden: hideExpandCollapseBtns,
                    items: [
                    {
                        xtype: 'button',
                        itemId: 'touchtreegridexpand',
                        cls  : 'touchtreegrid-expand-collapse-buttons',
                        text: 'Expand',
                        listeners : {
                            tap: function (button, e, options) {
                                me.doExpandDepth(99);
                            }
                        }
                    },
                    {
                        xtype: 'button',
                        itemId: 'touchtreegridcollapse',
                        cls  : 'touchtreegrid-expand-collapse-buttons',
                        text: 'Collapse',
                        listeners : {
                            tap: function (button, e, options) {
                                me.doExpandDepth(0);
                            }
                        }
                    }
                    ]

                }]
            });




            return Ext.factory(config, Ext.Toolbar);
        }
    },

    updateFooter: function(footer) {
        if (this.getIncludeFooter() && !this.getSimpleList()) {
            this.insert(0, footer);
        }
    },

    doExpandDepth: function(depth, btn) {
        var list = this.getList(),
            store = list.getStore();

        /* Unpress Expand/Collapse buttons in event they were pressed */
        if (!Ext.isEmpty(btn)) {
            var btns  = this.down('#touchtreegridsegmentedbuttons');
            btns.setPressedButtons([]);
        }

        // Fire custom event for expand/collapse if specified
        var customEvent = this.getCustomExpCollapseEvent();
        if (customEvent !== '') {
            this.fireEvent(customEvent, {collapseLevel: depth, list: list, gridcont: this});
            return;
        }

        store.each(function(item, index, list) {item.collapse(true);});

        function expandDepth(node) {
            if (!node.isLeaf() && node.data.depth <depth) {
                node.expand(false);

                node.childNodes.forEach(expandDepth, this);
            }
        }
        store.each(expandDepth, this);

        // Added 8/19/2013
        var scroller = list.getScrollable().getScroller();
        scroller.scrollTo(0,1);

    },

    doRefreshList: function(skipApplyDefaultCollapseLevel) {
        // Refreshes TPL in grid and in Header

        var me = this;

        var simpleList = me.getSimpleList();

        var list = me.getList();
        var disclose = me.getOnItemDisclosure();
        var colorArr = me.getCategDepthColorsArr();
        var categCssArr = me.getCategCssArr();
        var colorDepth = me.getCategDepthColors();
        var colorDepthButtons = me.getCategDepthColorButtons();
        var arrowWid = me.getArrowPctWidth(); // allow control over percent screen width that category arrow consumes (def = 4%)

        var itemTpl;

        // Customize TPL to change colors by category depth as defined in colorArr
        var colorStyle = (colorDepth ? ' style="background-color: {[this.depthColor(values)]} !important;"' : '');
        var categCss = '{[this.depthCategCss(values)]}';

        var tpl;
        if (!simpleList) {

            tpl = [
            '<tpl if="leaf">',
            '<div class="touchtreegrid-list-content">',
            me.getContentItemTpl(),
            '</div>',
            '<tpl else>',
            '<div class="' + categCss + '" ' + colorStyle + '> ',
            me.getCategItemTpl(),
            '</div>',
            '</tpl>'
            ].join('');

        } else {
            tpl = [
            //    '<div class="touchtreegrid-list-content">',
            me.getContentItemTpl()
            //   '</div>'
            ].join('');
        }

        var renderers = {};
        renderers.scope = me;
        renderers.isExpanded = function(values) {return values.expanded;};
        renderers.depthColor = function(values) {return (!colorArr[values.depth-1] ? 'white' : colorArr[values.depth-1]);};
        renderers.depthCategCss = function(values) {return (!categCssArr[values.depth-1] ? ' touchtreegrid-list-categ' : ' '+categCssArr[values.depth-1]);};
        renderers.formatNumbers = function(n, decPlaces, prefix, thouSeparator, decSeparator) {return me.formatNumbers(n, decPlaces, prefix, thouSeparator, decSeparator);};

        // SWL added JAN2015
        renderers.renderer_myForm = function(myClass, myHeight, values) {return me.renderer_myForm(myClass, myHeight, values);};

        var customRenderers = me.getRenderers();
        for (var prop in customRenderers) {
            renderers[prop] = customRenderers[prop];
        }

        itemTpl = Ext.create('Ext.XTemplate', tpl, renderers);

        itemTpl.compile();

        list.setItemTpl(itemTpl);

        if (simpleList) {list.refresh();}

        /* Build Header TPL */
        var header = me.getHeader();
        var data = me.getColumns();

        var styleStr='', cssStr='';
        var headerStyle = Ext.isEmpty(me.getStyleHeaderRow()) ? '' : ' style="' + me.getStyleHeaderRow() + '"';
        var headerCss = Ext.isEmpty(me.getCssHeaderRow()) ? '' : ' class="' + me.getCssHeaderRow() + '"';

        var headerTpl = me.getHeaderTplOverride();
        if (headerTpl==='') {

            var headerTplArr = [
            '<div' + headerStyle + headerCss + '>'
            ];
            if (!simpleList) {
                // Include spacer width for category arrow
                headerTplArr.push('<p align="left" style="width:'+arrowWid+'%;min-width:'+arrowWid+'%;max-width:'+arrowWid+
                '%;white-space: nowrap;overflow:hidden;text-overflow:ellipsis;">&nbsp;</p>');
            }

            for (var j=0; j<data.length; j++) {

                // Use headerStyle if exists, else apply detail row style to category row
                if (data[j].headerStyle && data[j].headerStyle > '') {styleStr = data[j].headerStyle;}
                else if (data[j].style) {styleStr = data[j].style;}
                else {styleStr = '';}

                // Use headerCss if exists, else apply detail row css to header row (if defined)
                if (!Ext.isEmpty(data[j].headerCss) && data[j].headerCss > '') {cssStr = data[j].headerCss;}
                else if (!Ext.isEmpty(data[j].css)) {cssStr = data[j].css;}
                else {cssStr = '';}

                headerTplArr.push('<div class="touchtreegrid-header-cell ' + cssStr +
                (!Ext.isEmpty(data[j].initSortCls) ? ' '+data[j].initSortCls : '') + // see comments in handleColumnSort()
                '" style="min-width:' + data[j].width +' !important;' +
                'max-width:'+data[j].width + ' !important; width:' + data[j].width + ' !important;' +
                styleStr + '" dataIndex="'+data[j].dataIndex+'">' + data[j].header + '</div>');
            }
            headerTplArr.push('</div>');

            // Wrap with spacer to accomodate for disclosure icon(lines up columns better)
            var headerTplArr2 = [];
            if (disclose) {
                headerTplArr2.push('<div class="touchtreegrid-disclose-spacer">');
                headerTplArr2 = headerTplArr2.concat(headerTplArr);
                headerTplArr2.push('</div>');
            } else {
                headerTplArr2 = headerTplArr;
            }

            headerTpl=headerTplArr2.join('');
        }
        if (this.getIncludeHeader()) {
            header.setHtml(headerTpl);
        }


        if (me.getApplyDefaultCollapseLevel() && !skipApplyDefaultCollapseLevel && !simpleList) {
            // custom implementations can request not to change collapse levels when refreshing
            me.doExpandDepth(me.getDefaultCollapseLevel());
        }

        var btns = me.down('#touchtreegridbuttons');
        var customFooterItems = me.getCustomFooterItems();
        var includeCustomFooterItems = me.getIncludeCustomFooterItems();

        if (me.getIncludeFooter() && !simpleList && !me.isObjectEmpty(customFooterItems) && !Ext.isEmpty(btns) &&
        Ext.isEmpty(btns.down('#'+customFooterItems.itemId)) && includeCustomFooterItems) {
            btns.add(customFooterItems);
        }

        if (me.getIncludeFooter() && me.getIncludeFooterLevels() && !simpleList) {
            // Proceed to add expand/collapse levels  (horizontal scrolling toolbar LATER)

            // First get total depth of treestore
            var store = list.getStore();
            maxDepth=0;

            function doDrillDown(node) {
                if (!node.isLeaf()) {
                    maxDepth = ((node.data.depth>maxDepth) ? node.data.depth : maxDepth);

                    node.childNodes.forEach(doDrillDown, me);
                }
            }
            store.each(doDrillDown, me);

            if (maxDepth>1 && !Ext.isEmpty(btns)) {
                // Remove button items 1+ if they exist

                var itms = btns.getItems();
                var itmsOrigLength = itms.items.length;
                var thisItemId, k;

                for (k = 2; k<10; k++) {  // blindly loop to delete up to 8 category level buttons with matching ItemId names
                    thisItem = btns.down('#touchtreegriddepth'+k.toString());
                    if (!Ext.isEmpty(thisItem)) {
                        btns.remove(thisItem, true);
                    }
                }


                var btnStyle = {};

                // Add buton for each additional level
                var newbtn;
                for (var i=2; i <= maxDepth; i++) {
                    if (colorDepth && colorDepthButtons) {
                        btnStyle = {'background' : (!colorArr[i-1] ? 'white' : colorArr[i-1]),
                        'color' : 'black'};
                    }
                    newbtn = {
                        xtype: 'button',
                        itemId: 'touchtreegriddepth'+i.toString(),
                        cls  : 'touchtreegrid-expand-collapse-buttons',
                        style : btnStyle,
                        depth : i,
                        text: i.toString(),
                        listeners : {tap: function (button, e, options) {me.doExpandDepth(button.config.depth, button);}}
                    };

                    btns.add(newbtn);
                }

            }
        }

    },

    formatNumbers: function(n, decPlaces, prefix, suffix, thouSeparator, decSeparator) {
        if (Ext.isEmpty(n)) {return n;};  // Don't format empty strings  =="" || !n || isNaN(n)
        decPlaces = (isNaN(decPlaces = Math.abs(decPlaces)) ? 2 : decPlaces);
        prefix = (prefix == undefined ? "" : prefix);   // Example pass "$" sign for currency
        suffix = (suffix == undefined ? "" : suffix);   // Example pass "%" sign for percents

        decSeparator = (decSeparator == undefined ? "." : decSeparator);
        thouSeparator = (thouSeparator == undefined ? "," : thouSeparator);
        sign = (n < 0 ? "-" : "");
        i = parseInt(n = Math.abs(+n || 0).toFixed(decPlaces)) + "";
        j = (((j = i.length) > 3) ? (j % 3) : 0);
        return prefix + sign + (j ? i.substr(0, j) + thouSeparator : "") +
        i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + thouSeparator) +
        (decPlaces ? decSeparator + Math.abs(n - i).toFixed(decPlaces).slice(2) : "") + suffix;
    },

    isObjectEmpty: function(myObj) {
        for(var key in myObj) {
            if (myObj.hasOwnProperty(key)) {
                return false;
            }
        }
        return true;
    },

    handleColumnSort: function(e,t) {
        // Refer to updateHeader() for code to add tap listener on header toolbar
        //  header.element.on('tap', me["handleColumnSort"], me, {});

        var me        = this,
            list      = me.getList(),
            grouped   = list.getGrouped(),
            columns   = me.getColumns(),
            cNum      = columns.length,
            store     = list.getStore(),
            el        = Ext.get(t),
            headerEl  = me.down('#touchtreegridheader').element,
            dataIndex = el.getAttribute('dataIndex'),
            sorters   = store.getSorters(),
            asc       = 'x-grid-sort-asc',
            desc      = 'x-grid-sort-desc',
            myEvent   = me.getCustomColumnSortEvent(),
            columnsUpdated = false,
            c, i, colIndex, column, columnsUpd=[], colEl, sorter, dir,
            grouper, grouperSortProperty, grouperDirection, grouperProperty, mySortIdx, newDirCls;

        if (!dataIndex) return;  //Included in event of tap on extra toolbar space at far right

        for (c=0; c < cNum; c++) {
            column = columns[c];
            if (column.dataIndex === dataIndex) {break;}
        }
        colIndex = c;

        if (myEvent !== '') {
            // Custom event specified to be fired in lieu of default processing
            me.fireEvent(myEvent,{me: me, e: e, t: t,  el: el, headerEl: headerEl,
            dataIndex: dataIndex, column: column});
            return;
        }

        if (!column.sortable) return;

        grouper = store.getGrouper();
        if (!Ext.isEmpty(grouper)) {
            grouperProperty = grouper.getProperty();
            grouperSortProperty = grouper.getSortProperty();
            grouperDirection = Ext.isEmpty(grouper.getDirection()) ? 'ASC' : grouper.getDirection();
        }

        // sorters array may be prefilled with grouper-related sorts, last index is one for my current column sort
        mySortIdx = sorters.length-1;
        sorter    = sorters[mySortIdx];
        dir       = sorter ? sorter.getDirection() : 'ASC';
        newDirCls = (dir === 'DESC' ? desc : asc);


        // Sort items within grouper if defined
        if (Ext.isEmpty(grouper)){
            store.sort([{property: dataIndex, direction: dir === 'DESC' ? 'ASC' : 'DESC'}]);
        } else {
            store.sort([{property: grouperSortProperty, direction: grouperDirection},
            {property: dataIndex, direction: dir === 'DESC' ? 'ASC' : 'DESC'}]);
        }

        // Copy columns[], update the copy then restore so that updateColumns() method isn't
        // invoked via updateColumns() method until all updates are complete
        columnsUpd = Ext.clone(columns);

        // Remove any prior sort indicators
        for (c=0; c < cNum; c++) {
            colEl = Ext.get(headerEl.down('div.touchtreegrid-header-cell[dataIndex=' + columns[c].dataIndex + ']'));
            if (!me.isObjectEmpty(colEl)) {
                colEl.removeCls(asc);
                colEl.removeCls(desc);
            }


            // Process column shading if sorted properties are defined in columns[] array:
            // => headerStyleSorted, categStyleSorted, styleSorted
            if (c===colIndex) {
                // Save Original styles and update with sorted styles  (STYLE will override CSS if defined)
                if (!Ext.isEmpty(columnsUpd[c].headerCssSorted) && !Ext.isEmpty(columnsUpd[c].headerCss)) {
                    if (Ext.isEmpty(columnsUpd[c].headerCssOrig)) {
                        columnsUpd[c].headerCssOrig = columnsUpd[c].headerCss;
                    }
                    if (columnsUpd[c].headerCss !== columnsUpd[c].headerCssSorted) {
                        columnsUpd[c].headerCss = columnsUpd[c].headerCssSorted;
                        columnsUpd[c].initSortCls = newDirCls;   // Store new CLS to array so that doRefreshList() will render sort arrow correctly when redrawing
                        columnsUpdated = true;
                    }
                }
                if (!Ext.isEmpty(columnsUpd[c].headerStyleSorted) && !Ext.isEmpty(columnsUpd[c].headerStyle)) {
                    if (Ext.isEmpty(columnsUpd[c].headerStyleOrig)) {
                        columnsUpd[c].headerStyleOrig = columnsUpd[c].headerStyle;
                    }
                    if (columnsUpd[c].headerStyle !== columnsUpd[c].headerStyleSorted) {
                        columnsUpd[c].headerStyle = columnsUpd[c].headerStyleSorted;
                        columnsUpd[c].initSortCls = newDirCls;   // Store new CLS to array so that doRefreshList() will render sort arrow correctly when redrawing
                        columnsUpdated = true;
                    }
                }


                if (!Ext.isEmpty(columnsUpd[c].categCssSorted) && !Ext.isEmpty(columnsUpd[c].categCss)) {
                    if (Ext.isEmpty(columnsUpd[c].categCssOrig)) {
                        columnsUpd[c].categCssOrig = columnsUpd[c].categCss;
                    }
                    if (columnsUpd[c].categCss !== columnsUpd[c].categCssSorted) {
                        columnsUpd[c].categCss = columnsUpd[c].categCssSorted;
                        columnsUpdated = true;
                    }
                }
                if (!Ext.isEmpty(columnsUpd[c].categStyleSorted) && !Ext.isEmpty(columnsUpd[c].categStyle)) {
                    if (Ext.isEmpty(columnsUpd[c].categStyleOrig)) {
                        columnsUpd[c].categStyleOrig = columnsUpd[c].categStyle;
                    }
                    if (columnsUpd[c].categStyle !== columnsUpd[c].categStyleSorted) {
                        columnsUpd[c].categStyle = columnsUpd[c].categStyleSorted;
                        columnsUpdated = true;
                    }
                }


                if (!Ext.isEmpty(columnsUpd[c].cssSorted) && !Ext.isEmpty(columnsUpd[c].css)) {
                    if (Ext.isEmpty(columnsUpd[c].cssOrig)) {
                        columnsUpd[c].cssOrig = columnsUpd[c].css;
                    }
                    if (columnsUpd[c].css !== columnsUpd[c].cssSorted) {
                        columnsUpd[c].css = columnsUpd[c].cssSorted;
                        columnsUpdated = true;
                    }
                }
                if (!Ext.isEmpty(columnsUpd[c].styleSorted) && !Ext.isEmpty(columnsUpd[c].style)) {
                    if (Ext.isEmpty(columnsUpd[c].styleOrig)) {
                        columnsUpd[c].styleOrig = columnsUpd[c].style;
                    }
                    if (columnsUpd[c].style !== columnsUpd[c].styleSorted) {
                        columnsUpd[c].style = columnsUpd[c].styleSorted;
                        columnsUpdated = true;
                    }
                }


            } else {
                // Restore Original styles for non-sorted columnsUpd
                if (!Ext.isEmpty(columnsUpd[c].headerCssOrig) && !Ext.isEmpty(columnsUpd[c].headerCss)) {
                    if (columnsUpd[c].headerCss !== columnsUpd[c].headerCssOrig) {
                        columnsUpd[c].headerCss = columnsUpd[c].headerCssOrig;
                        columnsUpd[c].initSortCls = '';      // reset
                        columnsUpdated = true;
                    }
                }
                if (!Ext.isEmpty(columnsUpd[c].headerStyleOrig) && !Ext.isEmpty(columnsUpd[c].headerStyle)) {
                    if (columnsUpd[c].headerStyle !== columnsUpd[c].headerStyleOrig) {
                        columnsUpd[c].headerStyle = columnsUpd[c].headerStyleOrig;
                        columnsUpd[c].initSortCls = '';      // reset
                        columnsUpdated = true;
                    }
                }

                if (!Ext.isEmpty(columnsUpd[c].categCssOrig) && !Ext.isEmpty(columnsUpd[c].categCss)) {
                    if (columnsUpd[c].categCss !== columnsUpd[c].categCssOrig) {
                        columnsUpd[c].categCss = columnsUpd[c].categCssOrig;
                        columnsUpdated = true;
                    }
                }
                if (!Ext.isEmpty(columnsUpd[c].categStyleOrig) && !Ext.isEmpty(columnsUpd[c].categStyle)) {
                    if (columnsUpd[c].categStyle !== columnsUpd[c].categStyleOrig) {
                        columnsUpd[c].categStyle = columnsUpd[c].categStyleOrig;
                        columnsUpdated = true;
                    }
                }

                if (!Ext.isEmpty(columnsUpd[c].cssOrig) && !Ext.isEmpty(columnsUpd[c].css)) {
                    if (columnsUpd[c].css !== columnsUpd[c].cssOrig) {
                        columnsUpd[c].css = columnsUpd[c].cssOrig;
                        columnsUpdated = true;
                    }
                }
                if (!Ext.isEmpty(columnsUpd[c].styleOrig) && !Ext.isEmpty(columnsUpd[c].style)) {
                    if (columnsUpd[c].style !== columnsUpd[c].styleOrig) {
                        columnsUpd[c].style = columnsUpd[c].styleOrig;
                        columnsUpdated = true;
                    }
                }
            }
        }

        if (columnsUpdated) {
            me.setColumns(columnsUpd);
            me.doRefreshList();
        }
        else {list.refresh();}

        // Apply sort indicator to tapped column  (need this after doRefreshList() called .. but also handled in doRefreshList do to race conditioons)
        var newEl = el.addCls(newDirCls);

        // Added 10/3/13
        var linkedGridsArr = me.prepLinkedGridsArr();
        if (linkedGridsArr.length > 0) {
            // Remove any existing sort indicators and styling for linked grids
            for (i=0; i<linkedGridsArr.length; i++) {
                linkedGridsArr[i].item.suspendEvents();  // item updated in onScroll()
            }

            for (i=0; i<linkedGridsArr.length; i++) {
                linkedGridsArr[i].item.removeColumnSorts();
            }

            for (i=0; i<linkedGridsArr.length; i++) {
                linkedGridsArr[i].item.resumeEvents(true);
            }
        }



    },

    removeColumnSorts: function() {
        // Added 10/3/13

        // Called to clear all header and column sort-related CLS/Styles.
        // Introduced to support column sorting across freeze column panels.
        var
        me        = this,
        headerEl  = me.down('#touchtreegridheader').element,
        columns   = me.getColumns(),
        cNum      = columns.length,
        list      = me.getList(),
        asc       = 'x-grid-sort-asc',
        desc      = 'x-grid-sort-desc',
        c, colEl, columnsUpdated;

        var columnsUpd = Ext.clone(columns);


        for (c=0; c < cNum; c++) {
            colEl = Ext.get(headerEl.down('div.touchtreegrid-header-cell[dataIndex=' + columns[c].dataIndex + ']'));
            if (!me.isObjectEmpty(colEl)) {
                colEl.removeCls(asc);
                colEl.removeCls(desc);
            }


            // Restore Original styles for non-sorted columnsUpd
            if (!Ext.isEmpty(columnsUpd[c].headerCssOrig) && !Ext.isEmpty(columnsUpd[c].headerCss)) {
                if (columnsUpd[c].headerCss !== columnsUpd[c].headerCssOrig) {
                    columnsUpd[c].headerCss = columnsUpd[c].headerCssOrig;
                    columnsUpd[c].initSortCls = '';      // reset
                    columnsUpdated = true;
                }
            }
            if (!Ext.isEmpty(columnsUpd[c].headerStyleOrig) && !Ext.isEmpty(columnsUpd[c].headerStyle)) {
                if (columnsUpd[c].headerStyle !== columnsUpd[c].headerStyleOrig) {
                    columnsUpd[c].headerStyle = columnsUpd[c].headerStyleOrig;
                    columnsUpd[c].initSortCls = '';      // reset
                    columnsUpdated = true;
                }
            }

            if (!Ext.isEmpty(columnsUpd[c].categCssOrig) && !Ext.isEmpty(columnsUpd[c].categCss)) {
                if (columnsUpd[c].categCss !== columnsUpd[c].categCssOrig) {
                    columnsUpd[c].categCss = columnsUpd[c].categCssOrig;
                    columnsUpdated = true;
                }
            }
            if (!Ext.isEmpty(columnsUpd[c].categStyleOrig) && !Ext.isEmpty(columnsUpd[c].categStyle)) {
                if (columnsUpd[c].categStyle !== columnsUpd[c].categStyleOrig) {
                    columnsUpd[c].categStyle = columnsUpd[c].categStyleOrig;
                    columnsUpdated = true;
                }
            }

            if (!Ext.isEmpty(columnsUpd[c].cssOrig) && !Ext.isEmpty(columnsUpd[c].css)) {
                if (columnsUpd[c].css !== columnsUpd[c].cssOrig) {
                    columnsUpd[c].css = columnsUpd[c].cssOrig;
                    columnsUpdated = true;
                }
            }
            if (!Ext.isEmpty(columnsUpd[c].styleOrig) && !Ext.isEmpty(columnsUpd[c].style)) {
                if (columnsUpd[c].style !== columnsUpd[c].styleOrig) {
                    columnsUpd[c].style = columnsUpd[c].styleOrig;
                    columnsUpdated = true;
                }
            }
        }

        if (columnsUpdated) {
            me.setColumns(columnsUpd);
            me.doRefreshList();
        }
        else {list.refresh();}

    },

    onScroll: function(scroller, x, y) {
        // Scroll all linked grids
        var me = this, i, linkedGridsArr;

        linkedGridsArr = me.prepLinkedGridsArr();
        if (linkedGridsArr.length === 0) {return;}

        scroller.suspendEvents();
        for (i=0; i<linkedGridsArr.length; i++) {
        //    linkedGridsArr[i].scroller.suspendEvents();
        }

        for (i=0; i<linkedGridsArr.length; i++) {
            otherX = linkedGridsArr[i].scroller.position.x;
            linkedGridsArr[i].scroller.scrollTo(otherX,y);
        }

        scroller.resumeEvents(true);
        for (i=0; i<linkedGridsArr.length; i++) {
        //    linkedGridsArr[i].scroller.resumeEvents(true);
        }

    },

    prepLinkedGridsArr: function(skipRecurse) {
        // SWL UPDATED 1/17/2015 TO SUPPORT RESIZING OF LOCKED COLUMNS

        // Adds object references to linkdedGridsArr from itemId's of linked grids for faster scrolling and sorting performance across the grids
        var me = this, i, listItemId, otherList, otherListItemId, otherScroller, parcont, linkedGridsArr, gridlist, gridlistItemId, othercont;

        gridlistItemId = me.getListItemId();
        gridlist = me.down('#'+gridlistItemId);

        if (typeof skipRecurse !== 'boolean'){skipRecurse = false;} // When called from event

        linkedGridsArr = me.getLinkedGridsArr();
        if (linkedGridsArr.length === 0) {return [];}

        parcont = me.up('#'+me.getLinkedGridsParentItemId());

        if (Ext.isEmpty(parcont)) {
            if (me.isRendered()){
                console.log(me.getLinkedGridsParentItemId() + ' not found !');
            }
            return [];
        }

        if (Ext.isEmpty(linkedGridsArr[0].scroller)) {
            // One-time update of linked scroller and gridcont objects for current linked instance of TouchTreeGrid
            for (i=0; i<linkedGridsArr.length; i++) {
                othercont = parcont.down('#'+linkedGridsArr[i].itemId);
                if (Ext.isEmpty(othercont)) {
                    console.log('Unable to find ' + linkedGridsArr[i].itemId);
                    return;
                }
                otherListItemId = othercont.getListItemId();
                otherList = othercont.down('#'+otherListItemId);
                otherScroller = otherList.getScrollable().getScroller();
                linkedGridsArr[i].item = othercont;
                linkedGridsArr[i].scroller = otherScroller;

            }

            // Similarly update each linked grid
            if (!skipRecurse) {
                othercont.prepLinkedGridsArr(true);  // Only recurse once as all other grids are defined in linkdedGridsArr[] already
            }
            me.setLinkedGridsArr(linkedGridsArr);
        }

        if (me.getIncludeThumb() && !me.thumb){

            var thumb,
                thumbConfig = me.getThumbConfig(),
                includeThumb = me.getIncludeThumb(),
                colWidth = me.getWidth(),
                colWidthNum,
                colWidthVal,
                colWidthUnit = null,
                colListWidthNum,
                colListWidthVal;

            if (colWidth){
                colWidthNum = colWidth.replace(/[^0-9]/g, '');
                colWidthVal = parseInt(colWidthNum);
                colWidthUnit = colWidth.replace(colWidthNum, '');
                colListWidthNum = gridlist.getWidth().replace(/[^0-9]/g, '');
                colListWidthVal = parseInt(colListWidthNum);
            }


            if (includeThumb && parcont && colWidthUnit !== 'px') {
                me.thumb='invalid width'; // prevents repeated errors
                console.log(gridlistItemId + ' width units must be defined in pixels with no flex for thumb support');
            }
            if (includeThumb && parcont && colWidthUnit === 'px'){

                var thumbConfig = me.getThumbConfig(),
                    thumbClassName = thumbConfig.className,
                    thumbWidth = thumbConfig.width,
                    thumbWidthNum = thumbWidth.replace(/[^0-9]/g, ''),
                    thumbWidthUnit = thumbWidth.replace(thumbWidthNum, ''),
                    thumbAdjust = parseInt(thumbConfig.offset.replace(/[^0-9]/g, '')),
                    thumbLeftNum = colWidthNum - (thumbWidthNum/2)-thumbAdjust,  // center on border
                    thumbLeft = thumbLeftNum.toString() + thumbWidthUnit,
                    colMinWidthNum = (me.getMinWidth() ? me.getMinWidth().replace(/[^0-9]/g, '') : '0'),
                    colMinWidthVal = parseInt(colMinWidthNum),
                    thumbMinX = Math.max((-1 * (colWidthNum-(thumbWidthNum/2))), (-1*(colWidthNum-colMinWidthVal-(thumbWidthNum/2)))),  // # pixels allowed to drag left no more than width of grid plus minWidth if defined
                    scrnwid = (window.innerWidth > 0) ? window.innerWidth : screen.width,
                    colMaxWidthNum = (me.getMaxWidth() ? me.getMaxWidth().replace(/[^0-9]/g, '') : '99999'),
                    colMaxWidthVal = parseInt(colMaxWidthNum),
                    thumbMaxX = Math.min((scrnwid - me.element.getLeft() - colWidthVal - (thumbWidthNum/2)),
                                         (colMaxWidthVal - colWidthVal) );  // compute remaining pixels to right, or maxWidth whichever is less

                if (colWidthUnit !== 'px' || thumbWidthUnit !== 'px') {
                    console.log('Grid and thumb width units must be defined in pixels for thumb support');
                }

                thumbConfig = Ext.Object.merge({left: thumbLeft, itemId: me.getItemId()+'Thumb'}, thumbConfig);

                var thumb = Ext.create(thumbClassName, thumbConfig);

                var line;
                if (thumbConfig.includeLine){
                    line = Ext.create('Ext.Container',{
                        width: '2px',
                        height: '100%',
                        left: thumbLeftNum + thumbWidthNum/2 + thumbAdjust - 2,
                        top: 0,
                        style: 'background-color: transparent;',
                        zIndex: thumbConfig.zIndex-1
                    });
                }

                thumb.setDraggable(
                    {
                        direction: 'horizontal',
                        constraint: {
                            min: {x: thumbMinX, y: 0},
                            max: {x: thumbMaxX, y: 0}
                        },
                        initialOffset : {x: 0, y: 0},
                        listeners: {

                            drag: function(component, index, target, record, eventObject, options) {
                                if (thumbConfig.includeLine){
                                    line.setLeft(colWidthVal+component.offset.x-2);
                                }
                                if (thumbConfig.enableDrag){
                                    me.onThumbDrag({thumb: thumb, xValue: component.offset.x,
                                                    colWidthVal: colWidthVal, grid: me, colListWidthVal: colListWidthVal});
                                }
                            },
                            dragend: function(component, index, target, record, eventObject, options) {
                                if (thumbConfig.includeLine){
                                    line.setStyle('background-color: transparent;');
                                }
                                if (thumbConfig.enableDragEnd){
                                    me.onThumbDragEnd({thumb: thumb, xValue: component.offset.x,
                                                       colWidthVal: colWidthVal, grid: me, colListWidthVal: colListWidthVal});
                                }
                            },
                            dragstart: function(component, index, target, record, eventObject, options) {
                                if (thumbConfig.includeLine){
                                    line.setStyle('background-color: '+ (thumbConfig.lineColor ? thumbConfig.lineColor : 'red')+';');
                                }
                            }
                        }
                    }
                );


                parcont.insert(0, thumb);
                if (thumbConfig.includeLine){
                    parcont.insert(0, line);
                }
                me.thumb = thumb;
            }
        }
        return linkedGridsArr;
    },

    renderer_myForm: function(myClass, myHeight, values, classConfigs) {
        // SWL added JAN2015 to support forms in content (leaf) and category rows
        var me = this;
        var i, myForm, myStore, myRecId, myRec, items, flds, readOnly;

        classConfigs = classConfigs || {};
        var myConfigs = Ext.merge(classConfigs, {height: myHeight, values: values});

        myForm = Ext.create(myClass, myConfigs);

        myStore = me.down('#'+this.getListItemId()).getStore();

        myRecId       = values.id;
        myRec         = myStore.getById(myRecId);
        myForm.record = myRec;  // Save record with this instance of form
        myForm.touchtreegrid = me;  // Save touchtreegrid instance with form
        flds          = myRec.getFields();

        if (myRec.readOnly == undefined){
            // Use MyForm readOnly config until records are initialzied
            readOnly = (myForm.config.readOnly ? true : false);
            myRec.readOnly = readOnly;
        }
        else {
            readOnly = (myRec.readOnly ? true : false);
        }

        myForm.config.readOnly = readOnly; // update new instance of form for current record

        myForm.setRecord(myRec);  // Load record values into form

        function recurseItems(items) {
            var i, j, thisItems, childItems, textField, opts, thisOpt, fldName, radioName, fldName2;
            thisItems = items.items;
            if (!thisItems){return;}

            // Recursively step through all items
            for (i=0; i<thisItems.length; i++){
                // If Checkbox field, then add/remove "checkbox-checked" class based on mapped field name value
                if (thisItems[i].xtype === 'checkboxfield' && myRec.get(thisItems[i].getName())) {
                    thisItems[i].addCls('checkbox-checked');
                    thisItems[i].on('change', me.handleFormCheckboxfieldChange, myForm);

                }
                else if (thisItems[i].xtype === 'checkboxfield' && !myRec.get(thisItems[i].getName())) {
                    thisItems[i].removeCls('checkbox-checked');
                    thisItems[i].on('change', me.handleFormCheckboxfieldChange, myForm);
                }
                // If Radio field, then add/remove "radiofield-checked" class based on mapped field name value
                else if (thisItems[i].xtype === 'radiofield') {
                    // Radio and Checkboxes readOnly handled in 'check' event controller methods
                    fldName = thisItems[i].getName()+"_"+thisItems[i].getItemId();
                    radioName = thisItems[i].getName();
                    if (!myRec[radioName]){
                        myRec[radioName] = [];
                    }
                    if (flds.keys.indexOf(fldName) !== -1) {  // Chech that field exists for radiofield  (TBD: AUTOCREATE LATER?)
                        if (!myRec[fldName+'_init']){  // Initialize this record
                            myRec[fldName+'_init']=true;  // Set record value from component first time only

                            myStore.suspendEvents();
                            myRec.set(fldName, thisItems[i].getChecked());
                            myStore.resumeEvents(true);
                            myRec[radioName].push(thisItems[i]);  // stack all grouped radio components for traversal when unchcking all other radiofields
                        }
                        if (myRec.get(fldName)){ // Manually process all radiofields from checked one (ignore unchecked ones)
                            if (thisItems[i].getCls().indexOf('radiofield-checked') === -1){
                                thisItems[i].suspendEvents(true);
                                thisItems[i].addCls('radiofield-checked');


                                thisItems[i]._checked = true;  // manual updates avoid event firing
                                thisItems[i].getComponent().input.dom.checked = true;
                                thisItems[i].resumeEvents(true);
                            }

                            if (!myRec[fldName+'_init']){
                                for (j=0; j<myRec[radioName].length; j++){
                                    if (myRec[radioName][j] !== thisItems[i] &&
                                        myRec[radioName][j].getCls().indexOf('radiofield-checked') !== -1){

                                        myRec[radioName][j].suspendEvents();
                                        myRec[radioName][j].removeCls('radiofield-checked');
                                        myRec[radioName][j]._checked = false; // manually uncheck all others
                                        myRec[radioName][j].getComponent().input.dom.checked = false;
                                        myRec[radioName][j].resumeEvents(true);

                                        fldName2 = myRec[radioName][j].getName()+"_"+myRec[radioName][j].getItemId();
                                        myRec.set(fldName2, false);
                                    }
                                }
                            }
                        }
                        thisItems[i].on('check', me.handleFormRadiofieldCheck, myForm);

                    }
                    else {
                        console.log(fldName + ' field not defined  for radiofield');
                    }
                }
                else if (thisItems[i].xtype === 'selectfield' && (thisItems[i].getName())) {
                    // FOR TEXT FIELDS:  add value attribute in dom element
                    opts = thisItems[i].getOptions();
                    thisOpt = "";
                    for (j=0; j<opts.length; j++){
                        if (opts[j].value === thisItems[i].getValue()){
                            thisOpt = opts[j].text;
                            break;
                        }
                    }
                    thisItems[i].element.down('input').dom.setAttribute("value", thisOpt);
                    if (!thisItems[i].getReadOnly()){ // Don't override component-level readOnly setting
                        thisItems[i].setReadOnly(readOnly);
                    }
                    if (!readOnly && !thisItems[i].getReadOnly()){
                        thisItems[i].on('change', me.handleFormSelectfieldChange, myForm);
                    }
                }
                else if (thisItems[i].xtype === 'textfield' && (thisItems[i].getName())) {
                    // FOR TEXT FIELDS:  add value attribute in dom element
                    if (!thisItems[i].getReadOnly()){ // Don't override component-level readOnly setting
                        thisItems[i].setReadOnly(readOnly);
                    }
                    thisItems[i].element.down('input').dom.setAttribute("value", thisItems[i].getValue());
                    if (!readOnly && !thisItems[i].getReadOnly()){
                        thisItems[i].on('blur', me.handleFormTextfieldBlur, myForm);
                        thisItems[i].on('clearicontap', me.handleFormTextfieldClearicontap, myForm);
                    }
                }
                else if (thisItems[i].xtype === 'textareafield' && (thisItems[i].getName())) {
                    // For TextArea fields need to update textContent in DOM
                    thisItems[i].element.down('textarea').dom.textContent = thisItems[i].getValue();
                    if (!thisItems[i].getReadOnly()){ // Don't override component-level readOnly setting
                        thisItems[i].setReadOnly(readOnly);
                    }
                    if (!readOnly && !thisItems[i].getReadOnly()){
                        thisItems[i].on('blur', me.handleFormTextareaBlur, myForm);
                        thisItems[i].on('clearicontap', me.handleFormTextfieldClearicontap, myForm);
                    }
                }



                childItems = thisItems[i].items;
                if (childItems){
                    recurseItems(childItems);
                }
            }
        }

        //     Optional way to traverse components in form:
        //     Ext.each(myForm.query('textfield'), function() {
        //         this.setReadOnly(readOnly);
        //     });


        items = myForm.getItems();
        if (items) {
            recurseItems(items);
        }

        if (typeof myForm.postInit == 'function') {
            myForm.postInit();
        }

        var formHtml = myForm.element.dom.outerHTML;
        return formHtml;
    },

    handleFormTextfieldBlur: function(textfield, e, eOpts) {
        // SWL added JAN2015 to support forms in content (leaf) and category rows
        var myFormPanel = this;  // myForm scope defined in event listener definition
        // Only way I've found to get NewValue (so far) as change event doesn't reflect it with this implementation
        var newValue = e.target.getAttributeNode('value').ownerElement.value;
        if (myFormPanel.record.get(textfield.getName()) !== newValue) {  // Could be triggered from renderer_myForm so ignore
            myFormPanel.record.set(textfield.getName(), newValue);
        }
    },

    handleFormTextareaBlur: function(textfield, e, eOpts) {
        // SWL added JAN2015 to support forms in content (leaf) and category rows
        var myFormPanel = this;  // myForm scope defined in event listener definition
        var newValue = e.target.value;
        if (myFormPanel.record.get(textfield.getName()) !== newValue) {  // Could be triggered from renderer_myForm so ignore
            myFormPanel.record.set(textfield.getName(), newValue);
        }
    },

    handleFormTextfieldClearicontap: function(textfield, e, eOpts) {
        // SWL added JAN2015 to support forms in content (leaf) and category rows
        var myFormPanel = this;  // myForm scope defined in event listener definition
        myFormPanel.record.set(textfield.getName(), "");
    },

    handleFormSelectfieldChange: function(selectfield, newValue, oldValue, eOpts) {
        // SWL added JAN2015 to support forms in content (leaf) and category rows
        var myFormPanel = this;  // myForm scope defined in event listener definition
        if (myFormPanel.record.get(selectfield.getName()) !== newValue) {  // Could be triggered from renderer_myForm so ignore
            myFormPanel.record.set(selectfield.getName(), newValue);
        }
    },

    handleFormCheckboxfieldChange: function(checkboxfield, newValue, oldValue, eOpts) {
        // SWL added JAN2015 to support forms in content (leaf) and category rows
        var myFormPanel = this;  // myForm scope defined in event listener definition
        if (myFormPanel.config.readOnly || checkboxfield.config.readOnly){return;}
        var record = myFormPanel.record;

        var name = checkboxfield.getName();
        if (record.get(name) !== newValue) {  // Could be triggered from renderer_myForm so ignore
            record.set(name, newValue);
        }
    },

    handleFormRadiofieldCheck: function(checkboxfield, e, eOpts) {
        // SWL added JAN2015 to support forms in content (leaf) and category rows
        var myFormPanel = this;  // myForm scope defined in event listener definition
        if (myFormPanel.config.readOnly || checkboxfield.config.readOnly){return;}

        var fldName, myRec, myStore, j, fldName2, radioName;

        fldName   = checkboxfield.getName()+"_"+checkboxfield.getItemId();
        radioName = checkboxfield.getName();
        myRec     = myFormPanel.record;
        myStore   = myRec.stores[0];

        if (myRec){
            if (myRec[radioName]){  // Defined within TouchTreeGrid renderer_myForm() method upon initialization
                myStore.suspendEvents();
                for (j=0; j<myRec[radioName].length; j++){
                    if (myRec[radioName][j] !== checkboxfield){
                        fldName2 = myRec[radioName][j].getName()+"_"+myRec[radioName][j].getItemId();
                        if (myRec.get(fldName2)){
                            myRec.set(fldName2, false);  // Update all other radio buttons for this group as unchecked
                        }
                    }
                }
                myStore.resumeEvents(true);
            }
            myRec.set(fldName, true);  // This will trigger grid update to reprocess via TouchTreeGrid renderer_MyForm() method
        }

    },

    onThumbDragEnd: function(params) {
        // SWL UPDATED 1/17/2015 TO SUPPORT RESIZING OF LOCKED COLUMNS
        var newWidth, newWidthList, listItemId, gridlist;
        newWidth = (params.colWidthVal+params.xValue).toString()+'px';
        params.grid.setWidth(newWidth);

        newWidthList =  (params.xValue+params.colWidthVal-params.colListWidthVal < 0) ? params.colListWidthVal.toString()+'px' : newWidth;
        // If sliding left reset to original width to avoid text wrap
        var listItemId = params.grid.getListItemId();
        var gridlist = params.grid.down('#'+listItemId);
        gridlist.setWidth(newWidthList);
    },

    onThumbDrag: function(params) {
        // SWL UPDATED 1/17/2015 TO SUPPORT RESIZING OF LOCKED COLUMNS
        var newWidth, newWidthList, listItemId, gridlist;

        newWidth = (params.colWidthVal+params.xValue).toString()+'px';
        params.grid.setWidth(newWidth);

        newWidthList =  (params.xValue+params.colWidthVal-params.colListWidthVal < 0) ? params.colListWidthVal.toString()+'px' : newWidth;
        // If sliding left reset to original width to avoid text wrap
        var listItemId = params.grid.getListItemId();
        var gridlist = params.grid.down('#'+listItemId);
        gridlist.setWidth(newWidthList);
    }

});